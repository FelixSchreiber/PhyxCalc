# Grammatik-Regeln (kontextfrei, epsilonfrei, sonst allgemein)
# ------------------------------------------------------------
# Regeln müssen bezüglich der Rückgabewerte gruppiert sein!
# Nichtterminierte Symbole in Normklammern z.B. |A|
# Terminierte Symbole außerhalb der Normklammern
# Linksseitige Symbole ohne Klammern vor dem =
#
#
# \~ = any character except =,:,@,...
# \* = any character
#
# Definition needs following outline:
#   Rule            |   functions
S=|p1|              ; outputVariable
S=|string|=|p1|     ; variableAdd
S=|variable|=       ; variableRemove
S=|string|:=|p1|    ; constantAdd
S=|constant|:=      ; constantRemove
S=[|string|]        ; unitGroupAdd
S=[|unitGroup|]:=   ; unitGroupRemove
S=|string|:|unitGroup|=[|p1|]   ; unitCheckDimensionless, prefixAdd
S=|string|:|unitGroup|:i=[|p1|] ; unitCheckDimensionless, setInputOnlyFlag, prefixAdd
S=|prefix|:=                    ; prefixRemove
S=|string|=[]                           ; unitAdd                                                   //define base unit without unit system
S=|string|@|unitGroup|=[]               ; unitAdd                                                   //define base unit with unit system
S=|string|@|unitGroup|@|prefix|=[]      ; unitAdd                                                   //define base unit with unit system and prefered prefix
S=|string|=[|p1|]                       ; unitAdd                                                   //define derived unit without unit system
S=|string|@|unitGroup|=[|p1|]           ; unitAdd                                                   //define derived unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p1|]  ; unitAdd                                                   //define derived unit with unit system and prefered prefix
S=|string|=[|p1|]|p1|                       ; unitAdd                                               //define offset unit without unit system
S=|string|@|unitGroup|=[|p1|]|p1|           ; unitAdd                                               //define offset unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p1|]|p1|  ; unitAdd                                               //define offset unit with unit system and prefered prefix
S=|p1|->|p1|        ; unitCheckConvertible, unitConvert, outputVariable

#Priority 1: assignement
p1=|p2|

#Priority 2: conditional
p2=|p3|?|p3|:|p3|                     ; unitCheckDimensionless3th, valueCheckComplex3th, valueCheckInteger3th, conditionIfElse
p2=if|p3|then|p3|else|p3|             ; unitCheckDimensionless3th, valueCheckComplex3th, valueCheckInteger3th, conditionIfElse
p2=IF(|p3|\;|p3|\;|p3|)               ; unitCheckDimensionless3th, valueCheckComplex3th, valueCheckInteger3th, conditionIfElse
p2=|p3|

#Priority 3: logical OR and NOR
p3=|p3||OR||p4|         ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicOr
p3=|p3|NOR|p4|          ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicNor
p3=|p4|
OR=OR
OR=\|\|

#Priortiy 4: logical XOR
p4=|p4|XOR|p5|          ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicXor
p4=|p5|

#Priortiy 5:logical AND and NAND
p5=|p5||AND||p6|        ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicAnd
p5=|p5|NAND|p6|         ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicNand
p5=|p6|
AND=AND
AND=&&

#Priortiy 6: logical XAND
p6=|p6|XAND|p7|         ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, logicXand
p6=|p7|

#Priortiy 7: bitwise OR
p7=|p7||bOR||p8|        ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, bitOr
p7=|p8|
bOR=bOR
bOR=\|

#Priortiy 8: bitwise XOR
p8=|p8||bXOR||p9|       ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, bitXor
p8=|p9|
bXOR=bXOR
bXOR=^^

#Priority 9: bitwise AND
p9=|p9||bAND||p10|      ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, bitAnd
p9=|p10|
bAND=bAND
bAND=&

#Priority 10: equality
p10=|p10|==|p11|        ; logicEqual
p10=|p10|!=|p11|        ; logicNotEqual
p10=|p11|

#Priority 11: relational
p11=|p11|<|p12|         ; valueCheckComplex2, unitCheckConvertible, logicSmaller
p11=|p11|>|p12|         ; valueCheckComplex2, unitCheckConvertible, logicGreater
p11=|p11|<=|p12|        ; valueCheckComplex2, unitCheckConvertible, logicSmallerOrEqual
p11=|p11|>=|p12|        ; valueCheckComplex2, unitCheckConvertible, logicGreaterOrEqual
p11=|p12|

#Priority 12: shift
p12=|p12|<<|p13|        ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, bitShiftLeft
p12=|p12|>>|p13|        ; unitCheckDimensionless2, valueCheckComplex2, valueCheckInteger2, bitShiftRight
p12=|p13|

#Priority 13: additive
p13=|p13|+|p14|        ; unitCheckConvertible, valueAdd
p13=|p13|-|p14|        ; unitCheckConvertible, valueSub
p13=|p14|

#Priority 14: multiplicative
p14=|p14|*|p15|        ; unitMul, valueMul
p14=|p15||p17|         ; unitMul, valueMul
p14=|p17||p15|         ; unitMul, valueMul
p14=|p14|/|p15|        ; unitDiv, valueDiv
p14=|p15|

#Priority 15: powers
p15=|p15|^|p16|        ; unitPow, valuePow
p15=|p16|²            ; unitPow2, valuePow2
p15=|p16|³            ; unitPow3, valuePow3
p15=|p16|

#Priority 16: unary (prefix) operations, functions, numbers and units
p16=sin(|p1|)        ; unitCheckDimensionless, valueSin
p16=arcsin(|p1|)     ; unitCheckDimensionless, valueArcsin
p16=cos(|p1|)        ; unitCheckDimensionless, valueCos
p16=arccos(|p1|)     ; unitCheckDimensionless, valueArccos
p16=tan(|p1|)        ; unitCheckDimensionless, valueTan
p16=arctan(|p1|)     ; unitCheckDimensionless, valueArctan
p16=sinh(|p1|)       ; unitCheckDimensionless, valueSinh
p16=arcsinh(|p1|)    ; unitCheckDimensionless, valueArcsinh
p16=cosh(|p1|)       ; unitCheckDimensionless, valueCosh
p16=arccosh(|p1|)    ; unitCheckDimensionless, valueArccosh
p16=tanh(|p1|)       ; unitCheckDimensionless, valueTanh
p16=arctanh(|p1|)    ; unitCheckDimensionless, valueArctanh
p16=exp(|p1|)        ; unitCheckDimensionless, valueExp
p16=ln(|p1|)         ; unitCheckDimensionless, valueLn
p16=log|p16|(|p1|)   ; unitCheckDimensionless2, valueLogn
p16=root|p16|(|p1|)  ; unitRoot, valueRoot
p16=sqrt(|p1|)       ; unitSqrt, valueSqrt
p16=abs(|p1|)        ; valueAbs
p16=max(|p1|,|p1|)   ; valueCheckComplex2, unitCheckConvertible, valueMax
p16=min(|p1|,|p1|)   ; valueCheckComplex2, unitCheckConvertible, valueMin
p16=avg(|p1|,|p1|)   ; valueCheckComplex2, unitCheckConvertible, valueAvg
p16=int(|p1|)        ; valueCheckComplex, valueInt
p16=trunc(|p1|)      ; valueCheckComplex, valueTrunc
p16=floor(|p1|)      ; valueCheckComplex, valueFloor
p16=round(|p1|)      ; valueCheckComplex, valueRound
p16=ceil(|p1|)       ; valueCheckComplex, valueCeil
p16=sign(|p1|)       ; valueCheckComplex, valueSign
p16=heaviside(|p1|)  ; valueCheckComplex, valueHeaviside
p16=rand()           ; valueRand
p16=randint()        ; valueRandint
p16=randg(|p1|,|p1|) ; valueCheckComplex2, unitCheckDimensionless2, valueRandg
p16=arg(|p1|)        ; complexArg
p16=norm(|p1|)       ; complexNorm
p16=conj(|p1|)       ; complexConj
p16=polar(|p1|)      ; complexPolar
p16=|p1|!            ; valueCheckComplex, valueCheckPositive, valueCheckInteger, unitCheckDimensionless, valueFaculty
p16=~|p1|            ; unitCheckDimensionless, valueCheckComplex, bitInv
p16=!|p1|            ; unitCheckDimensionless, valueCheckComplex, logicNot
p16=|var|            ; pushVariable
p16=|p17|

#Priority 17: postfix, variables, constants, pi
p17=(|p1|)
p17=|pi|             ; valuePi
p17=|variable|
p17=|constant|_
pi=π
pi=pi

#Numbers
uint=|n|
uint=|n||uint|
uinte=|uint||e||uint|
int=|uint|
int=|+-||uint|
inte=|int||e||int|
real=|int|
real=|int|.|uint|
reale=|real|
reale=|real||e||int|
complex=|reale|     ; bufferParameter, bufferValue
complex=|i||reale|  ; bufferParameter, bufferValue
complex=|reale||i|  ; bufferParameter, bufferValue
complex=|i|         ; bufferParameter, bufferValue
#var=|complex||unit|
var=|complex|
var=|complex||prefix||unit|
var=|prefix||unit|
prefix=
#unit=|prefix||unit|
+-=+
+-=-
e=e
e=E
i=i
i=j
n=0
n=1
n=2
n=3
n=4
n=5
n=6
n=7
n=8
n=9

#Strings
chars+=|any+|
chars+=|any+||chars|
chars=|any|
chars=|any||chars|
string="|chars+|"     ; bufferParameter, bufferString
string=|chars|       ; bufferParameter, bufferString
any+=\*
any=\~
