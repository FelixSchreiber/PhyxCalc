# Grammatik-Regeln (kontextfrei, epsilonfrei, sonst allgemein)
# ------------------------------------------------------------
# Regeln müssen bezüglich der Rückgabewerte gruppiert sein!
# Nichtterminierte Symbole in Normklammern z.B. |A|
# Terminierte Symbole außerhalb der Normklammern
# Linksseitige Symbole ohne Klammern vor dem =
# Spezialsymbole (positive Zahlen in Normklammern) sind:
# (alle ab 3 dürfen nur als einziges Symbol in einer Regel vorkommen)
# |0| Anfangs- und Endsymbol (automatisch!)
# |1| Abschnitt aus terminierten Symbolen (automatisch!)
# |2| N.N. (Groß-/Kleinschreibung)
# |3| String in Anführungszeichen ""
# |4| Folge von Leerzeichen
# |5| Folge von Ziffern
# |6| Variable
# |7| Zeichenfolge für neue Variable
# |8| terminiertes Symbol |
# |9| si-Präfix
# |10| 2-Stelliger si-Präfix (nämlich da = Deka)
# |11| Einheit
# |12| SI-Einheit
# |13| Folge von mindestens einer Ziffer mit Basis bis 36, klein
# |14| Folge von mindestens einer Ziffer mit Basis bis 36, groß
# |15| Einzelne Ziffer 0-9
# |16| Offset-Einheit
#
# \~ = any character except =,:,@
# \* = any character
#
# Definition needs following outline:
#   Rule        |   functions               |   param function  |   parameter
S=|p1|              ; outputVariable
S=|string|=|p1|     ; variableAdd
S=|variable|=       ; variableRemove
S=[|string|]        ; unitGroupAdd
S=[|unitGroup|]:=   ; unitGroupRemove
S=|string|:|unitGroup|=[|p1|]   ; unitCheckDimensionless, prefixAdd
S=|prefix|:=                    ; prefixRemove
S=|string|=[]                           ; unitAdd                                                   //define base unit without unit system
S=|string|@|unitGroup|=[]               ; unitAdd                                                   //define base unit with unit system
S=|string|@|unitGroup|@|prefix|=[]      ; unitAdd                                                   //define base unit with unit system and prefered prefix
S=|string|=[|p1|]                       ; unitAdd                                                   //define derived unit without unit system
S=|string|@|unitGroup|=[|p1|]           ; unitAdd                                                   //define derived unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p1|]  ; unitAdd                                                   //define derived unit with unit system and prefered prefix
S=|string|=[|p1|]|p1|                       ; unitAdd                                           //define offset unit without unit system
S=|string|@|unitGroup|=[|p1|]|p1|           ; unitAdd                                           //define offset unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p1|]|p1|  ; unitAdd                                           //define offset unit with unit system and prefered prefix
p1=|p1|+|p2|        ; unitCheckConvertible, valueAdd
p1=|p1|-|p2|        ; unitCheckConvertible, valueSub
p1=|p2|
p2=|p2|*|p3|        ; unitMul, valueMul
p2=|p2|/|p3|        ; unitDiv, valueDiv
#p2=|p2||p3|        ; unitMul, valueMul
p2=|p3|
p3=|p3|^|p4|        ; unitPow, valuePow
p3=|p4|²            ; unitPow2, valuePow2
p3=|p4|³            ; unitPow3, valuePow3
p3=|p4|
p4=sin(|p1|)        ; unitCheckDimensionless, valueSin
p4=arcsin(|p1|)     ; unitCheckDimensionless, valueArcsin
p4=cos(|p1|)        ; unitCheckDimensionless, valueCos
p4=arccos(|p1|)     ; unitCheckDimensionless, valueArccos
p4=tan(|p1|)        ; unitCheckDimensionless, valueTan
p4=arctan(|p1|)     ; unitCheckDimensionless, valueArctan
p4=sinh(|p1|)       ; unitCheckDimensionless, valueSinh
p4=arcsinh(|p1|)    ; unitCheckDimensionless, valueArcsinh
p4=cosh(|p1|)       ; unitCheckDimensionless, valueCosh
p4=arccosh(|p1|)    ; unitCheckDimensionless, valueArccosh
p4=tanh(|p1|)       ; unitCheckDimensionless, valueTanh
p4=arctanh(|p1|)    ; unitCheckDimensionless, valueArctanh
p4=exp(|p1|)        ; unitCheckDimensionless, valueExp
p4=ln(|p1|)         ; unitCheckDimensionless, valueLn
p4=log|p4|(|p1|)    ; unitCheckDimensionless2, valueLogn
p4=root|p4|(|p1|)   ; unitRoot, valueRoot
p4=sqrt(|p1|)       ; unitSqrt, valueSqrt
p4=abs(|p1|)        ; valueAbs
p4=max(|p1|,|p1|)   ; valueCheckComplex2, unitCheckConvertible, valueMax
p4=min(|p1|,|p1|)   ; valueCheckComplex2, unitCheckConvertible, valueMin
p4=int(|p1|)        ; valueCheckComplex, valueInt
p4=trunc(|p1|)      ; valueCheckComplex, valueTrunc
p4=floor(|p1|)      ; valueCheckComplex, valueFloor
p4=round(|p1|)      ; valueCheckComplex, valueRound
p4=ceil(|p1|)       ; valueCheckComplex, valueCeil
p4=sign(|p1|)       ; valueCheckComplex, valueSign
p4=heaviside(|p1|)  ; valueCheckComplex, valueHeaviside
p4=rand()           ; valueRand
p4=randint()        ; valueRandint
p4=randg(|p1|,|p1|) ; valueCheckComplex2, unitCheckDimensionless2, valueRandg
p4=|p1|!            ; valueCheckComplex, valueCheckPositive, valueCheckInteger, unitCheckDimensionless, valueFaculty
p4=|p5|
p5=(|p1|)
p5=pi               ; valuePi
p5=|var|            ; pushVariable
p5=|variable|
uint=|n|
uint=|n||uint|
uinte=|uint||e||uint|
int=|uint|
int=|+-||uint|
inte=|int||e||int|
real=|int|
real=|int|.|uint|
reale=|real|
reale=|real||e||int|
complex=|reale|     ; bufferParameter, bufferValue
complex=|i||reale|  ; bufferParameter, bufferValue
complex=|reale||i|  ; bufferParameter, bufferValue
complex=|i|         ; bufferParameter, bufferValue
#var=|complex||unit|
var=|complex|
var=|complex||prefix||unit|
var=|prefix||unit|
prefix=
#unit=|prefix||unit|
+-=+
+-=-
e=e
e=E
i=i
i=j
n=0
n=1
n=2
n=3
n=4
n=5
n=6
n=7
n=8
n=9
chars+=|any+|
chars+=|any+||chars|
chars=|any|
chars=|any||chars|
string="|chars+|"     ; bufferParameter, bufferString
string=|chars|       ; bufferParameter, bufferString
any+=\*
any=\~
