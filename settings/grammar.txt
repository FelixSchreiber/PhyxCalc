# Grammatik-Regeln (kontextfrei, epsilonfrei, sonst allgemein)
# ------------------------------------------------------------
# Regeln müssen bezüglich der Rückgabewerte gruppiert sein!
# Nichtterminierte Symbole in Normklammern z.B. |A|
# Terminierte Symbole außerhalb der Normklammern
# Linksseitige Symbole ohne Klammern vor dem =
#
#
# \~ = any character except =,:,@,...
# \* = any character
#
# Definition needs following outline:
#   Rule            |   functions
#S=|p3|              ; outputVariable
#S=|string|=|p3|     ; variableAdd
S=|variable|=       ; variableRemove
S=|string|:=|p3|    ; constantAdd
S=|constant|:=      ; constantRemove
S=[|string|]        ; unitGroupAdd
S=[|unitGroup|]:=   ; unitGroupRemove
S=|string|:|unitGroup|=[|p3|]   ; unitCheckDimensionless, prefixAdd
S=|string|:|unitGroup|:i=[|p3|] ; unitCheckDimensionless, setInputOnlyFlag, prefixAdd
S=|prefix|:=                    ; prefixRemove
S=|string|=[]                           ; unitAdd                                                   //define base unit without unit system
S=|string|@|unitGroup|=[]               ; unitAdd                                                   //define base unit with unit system
S=|string|@|unitGroup|@|prefix|=[]      ; unitAdd                                                   //define base unit with unit system and prefered prefix
S=|string|=[|p3|]                       ; unitAdd                                                   //define derived unit without unit system
S=|string|@|unitGroup|=[|p3|]           ; unitAdd                                                   //define derived unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p3|]  ; unitAdd                                                   //define derived unit with unit system and prefered prefix
S=|string|=[|p3|]|p3|                       ; unitAdd                                               //define offset unit without unit system
S=|string|@|unitGroup|=[|p3|]|p3|           ; unitAdd                                               //define offset unit with unit system
S=|string|@|unitGroup|@|prefix|=[|p3|]|p3|  ; unitAdd                                               //define offset unit with unit system and prefered prefix
S=|p3|->|p3|        ; unitCheckConvertible, unitConvert, outputVariable
S=|p3|->hex         ; unitCheckDimensionless, valueCheckInteger, valueCheckPositive, bufferHexString, outputString
S=|p3|->bin         ; unitCheckDimensionless, valueCheckInteger, valueCheckPositive, bufferBinString, outputString
S=|p1|              ; lowLevelRun

#Priority 1: sequential operator
p1=|p1|,|p2|       ; lowLevelAdd
p1=|p2|

#Priority 2: assignement
p2=|string|=|p3|    ; lowLevelAssignment
p2=|variable|=      ; lowLevelAssignmentRemove
p2=|variable|+=|p3| ; lowLevelCombinedAssignmentAdd
p2=|variable|-=|p3| ; lowLevelCombinedAssignmentSub
p2=|variable|*=|p3| ; lowLevelCombinedAssignmentMul
p2=|variable|/=|p3| ; lowLevelCombinedAssignmentDiv
p2=|variable|%=|p3| ; lowLevelCombinedAssignmentMod
p2=|variable|&=|p3| ; lowLevelCombinedAssignmentAnd
p2=|variable|\|=|p3| ; lowLevelCombinedAssignmentOr
p2=|variable|^=|p3| ; lowLevelCombinedAssignmentXor
p2=|variable|<<=|p3|; lowLevelCombinedAssignmentShiftLeft
p2=|variable|>>=|p3|; lowLevelCombinedAssignmentShiftRight
p2=|p3|             ; lowLevelOutput

#Priority 3: conditional
p3=|p4|?|p4|:|p4|                     ; unitCheckDimensionless3th, valueCheckInteger3th, conditionIfElse
p3=if|p4|then|p4|else|p4|             ; unitCheckDimensionless3th, valueCheckInteger3th, conditionIfElse
p3=IF(|p4|\;|p4|\;|p4|)               ; unitCheckDimensionless3th, valueCheckInteger3th, conditionIfElse
p3=|p4|

#Priority 4: logical OR and NOR
p4=|p4||OR||p5|         ; unitCheckDimensionless2, valueCheckInteger2, logicOr
p4=|p4|NOR|p5|          ; unitCheckDimensionless2, valueCheckInteger2, logicNor
p4=|p5|
OR=OR
OR=\|\|

#Priortiy 5: logical XOR
p5=|p5|XOR|p6|          ; unitCheckDimensionless2, valueCheckInteger2, logicXor
p5=|p6|

#Priortiy 6:logical AND and NAND
p6=|p6||AND||p7|        ; unitCheckDimensionless2, valueCheckInteger2, logicAnd
p6=|p6|NAND|p7|         ; unitCheckDimensionless2, valueCheckInteger2, logicNand
p6=|p7|
AND=AND
AND=&&

#Priortiy 7: logical XAND
p7=|p7|XAND|p8|         ; unitCheckDimensionless2, valueCheckInteger2, logicXand
p7=|p8|

#Priortiy 8: bitwise OR
p8=|p8||bOR||p9|        ; unitCheckDimensionless2, valueCheckInteger2, bitOr
p8=|p9|
bOR=bOR
bOR=\|

#Priortiy 9: bitwise XOR
p9=|p9||bXOR||p10|       ; unitCheckDimensionless2, valueCheckInteger2, bitXor
p9=|p10|
bXOR=bXOR
bXOR=^^

#Priority 10: bitwise AND
p10=|p10||bAND||p11|      ; unitCheckDimensionless2, valueCheckInteger2, bitAnd
p10=|p11|
bAND=bAND
bAND=&

#Priority 11: equality
p11=|p11|==|p12|        ; logicEqual
p11=|p11|!=|p12|        ; logicNotEqual
p11=|p12|

#Priority 12: relational
p12=|p12|<|p13|         ; valueCheckComplex2, unitCheckConvertible, logicSmaller
p12=|p12|>|p13|         ; valueCheckComplex2, unitCheckConvertible, logicGreater
p12=|p12|<=|p13|        ; valueCheckComplex2, unitCheckConvertible, logicSmallerOrEqual
p12=|p12|>=|p13|        ; valueCheckComplex2, unitCheckConvertible, logicGreaterOrEqual
p12=|p13|

#Priority 13: shift
p13=|p13|<<|p14|        ; unitCheckDimensionless2, valueCheckInteger2, bitShiftLeft
p13=|p13|>>|p14|        ; unitCheckDimensionless2, valueCheckInteger2, bitShiftRight
p13=|p14|

#Priority 14: additive
p14=|p14|+|p15|        ; unitCheckConvertible, valueAdd
p14=|p14|-|p15|        ; unitCheckConvertible, valueSub
p14=|p15|

#Priority 15: multiplicative
p15=|p15|*|p16|        ; unitMul, valueMul
p15=|p16||p18|         ; unitMul, valueMul
p15=|p18||p16|         ; unitMul, valueMul
p15=|p15|/|p16|        ; unitDiv, valueDiv
p15=|p15||mod||p16|    ; unitCheckDimensionless2, valueCheckInteger2, valueMod
p15=|p16|
mod=mod

#Priority 16: powers
#Not the optimal solution!
p16=|p18|^|p17|       ; unitCheckDimensionless, unitPow, valuePow
p16=|p16|^|p17|       ; unitCheckDimensionless, unitPow, valueNoPow
p16=|p18|²            ; valuePush2, unitPow, valuePow
p16=|p18|³            ; valuePush2, unitPow, valuePow
p16=|p17|²            ; valuePush2, unitPow, valueNoPow
p16=|p17|³            ; valuePush3, unitPow, valueNoPow
p16=|p17|

#Priority 17: unary (prefix) operations, numbers and units
p17=|p3|!            ;  unitCheckDimensionless, valueCheckInteger, valueCheckPositive, valueFaculty
p17=~|p3|            ; unitCheckDimensionless, valueCheckComplex, bitInv
p17=!|p3|            ; unitCheckDimensionless, valueCheckComplex, logicNot
p17=|var|            ; pushVariable
p17=|p18|

#Priority 18: functions, postfix, variables, constants, pi
p18=sin(|p3|)        ; unitCheckDimensionless, valueSin
p18=arcsin(|p3|)     ; unitCheckDimensionless, valueArcsin
p18=cos(|p3|)        ; unitCheckDimensionless, valueCos
p18=arccos(|p3|)     ; unitCheckDimensionless, valueArccos
p18=tan(|p3|)        ; unitCheckDimensionless, valueTan
p18=arctan(|p3|)     ; unitCheckDimensionless, valueArctan
p18=sinh(|p3|)       ; unitCheckDimensionless, valueSinh
p18=arcsinh(|p3|)    ; unitCheckDimensionless, valueArcsinh
p18=cosh(|p3|)       ; unitCheckDimensionless, valueCosh
p18=arccosh(|p3|)    ; unitCheckDimensionless, valueArccosh
p18=tanh(|p3|)       ; unitCheckDimensionless, valueTanh
p18=arctanh(|p3|)    ; unitCheckDimensionless, valueArctanh
p18=exp(|p3|)        ; unitCheckDimensionless, valueExp
p18=ln(|p3|)         ; unitCheckDimensionless, valueLn
p18=log|p17|(|p3|)   ; unitCheckDimensionless2, valueLogn
p18=root|p17|(|p3|)  ; unitRoot, valueRoot
p18=sqrt(|p3|)       ; unitSqrt, valueSqrt
p18=abs(|p3|)        ; valueAbs
p18=max(|p3|,|p3|)   ; valueCheckComplex2, unitCheckConvertible, valueMax
p18=min(|p3|,|p3|)   ; valueCheckComplex2, unitCheckConvertible, valueMin
p18=avg(|p3|,|p3|)   ; valueCheckComplex2, unitCheckConvertible, valueAvg
p18=int(|p3|)        ; valueCheckComplex, valueInt
p18=trunc(|p3|)      ; valueCheckComplex, valueTrunc
p18=floor(|p3|)      ; valueCheckComplex, valueFloor
p18=round(|p3|)      ; valueCheckComplex, valueRound
p18=ceil(|p3|)       ; valueCheckComplex, valueCeil
p18=sign(|p3|)       ; valueCheckComplex, valueSign
p18=heaviside(|p3|)  ; valueCheckComplex, valueHeaviside
p18=rand()           ; valueRand
p18=randi(|p3|)      ; unitCheckDimensionless, valueCheckInteger, valueCheckPositive, valueRandint
p18=randg(|p3|,|p3|) ; valueCheckComplex2, unitCheckDimensionless2, valueRandg
p18=Re(|p3|)         ; complexReal
p18=Im(|p3|)         ; complexImag
p18=arg(|p3|)        ; complexArg
p18=norm(|p3|)       ; complexNorm
p18=conj(|p3|)       ; complexConj
p18=polar(|p3|,|p3|) ; valueCheckComplex2, unitCheckDimensionless2, complexPolar
p18=(|p3|)
p18={|p3|}           ; unitClear
p18=|pi|             ; valuePi
p18=|variable|
p18=|constant|_
pi=π
pi=pi

#Numbers
uint=|n|
uint=|n||uint|
uinte=|uint||e||uint|
int=|uint|
int=|+-||uint|
inte=|int||e||int|
real=|int|
real=|int|.|uint|
real=.|uint|
reale=|real|
reale=|real||e||int|
hexpart=|nh|
hexpart=|nh||hexpart|
hex=0x|hexpart|
binpart=|nb|
binpart=|nb||binpart|
bin=0b|binpart|
complex=|reale|     ; bufferParameter, bufferValue
complex=|i||reale|  ; bufferParameter, bufferValue
complex=|reale||i|  ; bufferParameter, bufferValue
complex=|i|         ; bufferParameter, bufferValue
#var=|complex||unit|
var=|complex|
var=|complex||prefix||unit|
var=|prefix||unit|
var=|hex|       ; bufferParameter, bufferHex
var=|bin|       ; bufferParameter, bufferBin
prefix=
#unit=|prefix||unit|
+-=+
+-=-
e=e
e=E
i=i
i=j
n=0
n=1
n=2
n=3
n=4
n=5
n=6
n=7
n=8
n=9
nh=0
nh=1
nh=2
nh=3
nh=4
nh=5
nh=6
nh=7
nh=8
nh=9
nh=A
nh=B
nh=C
nh=D
nh=E
nh=F
nh=a
nh=b
nh=c
nh=d
nh=e
nh=f
nb=0
nb=1

#Strings
chars+=|any+|
chars+=|any+||chars|
chars=|any|
chars=|any||chars|
string="|chars+|"     ; bufferParameter, bufferString
string=|chars|       ; bufferParameter, bufferString
any+=\*
any=\~
